记录读书笔记，以便可以随时翻阅。同时，将书籍整理成要点，帮助记忆。

### 前端性能的重要性
**性能黄金法则：** 只有10%~20%的最终用户响应时间花在了下载HTML文档上，其余的80%~90%时间花在了下载页面中所有组件上。
### HTTP概述
HTTP是浏览器和服务器相互通信的客户端/服务器协议，由请求和响应组成。浏览器向一个特定的URL发送HTTP请求，URL对应的宿主服务器发回HTTP响应。
HTTP响应包含状态码，头和响应体。
1. 压缩
浏览器使用***Accept-Encoding***头声明它支持压缩。
服务器使用***Content-Encoding***头确认响应已被压缩。
`Accept-Encoding: gzip,deflate`
`Content-Encoding: gzip`
2. 条件GET请求（Conditional GET Requests）
`响应——Last-Modified: Wed, 22 Feb 2019 04:12;12 GMT`
`请求——If-Modified-Since:Wed, 22 Feb 2019 04:12;12 GMT`
`响应——304 not modified`
***ETag***和***If-None-Match***时条件GET请求的另一种方法。
3. Expires
`响应——Expires: Wed, 22 Feb 2019 04:12;12 GMT` 
只要未过期，浏览器不会发出请求，而直接使用缓存。
4. Keep-Alive，持久连接
`Connection： Keep-Alive`
`Connection:  close`
### 优化规则
1. 规则1——减少HTTP请求
页面组件（图片，脚本，样式表，Flash等）都会发出HTTP请求。改善响应时间的最简单途径就是减少HTTP请求的数量
    - 图片地图
允许在一个图片上关联多个URL，目标URL取决于用户单击了图片的哪个位置。
使用<area>元素在图片上定义热点区域（[area-MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area)）
    - CSS Sprites
将多个图片合并在一起。使用background-position调整图片的位置，使用width和hheight定义显示的区域大小。
    - 内联图片
以data：URL模式添加图片，编码会增加图片的大小，整体下载量会下降。
    - 合并脚本和样式表
2. 规则2——使用内容发布网络（CDN）
CDN是一组分布在不同地理位置的web服务器，缩短响应时间从而提高性能。
CDN用于发布静态内容，比如图片，脚本，样式表，Flash。
3. 规则3——添加Expires头
Web服务器使用Expires头告诉Web客户端直接使用一个组件的副本，直到指定时间为止。Expires要求服务器和客户端时间同步，所以使用Cache-Control max-age来消除这个限制。两者同时存在时，max-age指令将重写Expires头（HTTP规范）。
`Expires: Wed, 22 Feb 2019 04:12;12 GMT  `
 `Cache-Control:max-age=315360000`
如果想要更新缓存，最有效的办法就是更新链接，这样就会重新请求资源。
4.  规则4——压缩组件
`Accept-Encoding: gzip,deflate`
`Content-Encoding: gzip`
一般压缩的是脚本和样式表。图片和PDF等已经经过了压缩，没有必要再压缩。
**代理缓存**：如果浏览器经过代理发送请求，多个浏览器使用同一个代理，浏览器有支持和不支持压缩两种情况。为了同时满足两种情况，服务器响应头中设置***Vary：Accept-Encoding***，这样代理就可以缓存两个版本——压缩与未压缩的，然后根据浏览器是否包含Accept-Encoding而响应。
5.  规则5——将样式表放在顶部
使用LINK标签将样式表放在<head>中页面加载更快。
页面是逐步呈现的，如果样式表仍在加载，构建呈现树就是一种浪费。
6. 规则6——将脚本放在底部
页面逐步呈现会被阻止，直到所有样式表下载完成。使用脚本时，为了脚本以下的内容，逐步呈现被阻塞了。将脚本放在底部，越多的内容可以逐步呈现。
**并行下载**：浏览器并行执行HTTP请求，HTTP1.1规范，浏览器从每个主机名并行下载两个组件（实际并行数量根据浏览器的不同而不同）。将组件分配在不同的主机名下也可以提高性能。
**脚本阻塞**：脚本并行下载时被禁止的，即使时不同的主机名。其中一个原因是document.write来修改页面，因此浏览器会等待，以确保页面能够恰当布局。另一个原因是保证脚本能够按照正确的顺序执行。如果浏览器支持defer，放在head中同样不会阻塞脚本。
最好依然是放在底部
7. 规则7——避免css表达式
如果真的需要可以使用一次性表达式（执行之后将表达式置换）或者使用事件处理器改变样式。
8. 规则8——使用外部javascript和css
目前基本上已经是标配，所以不详细介绍
9. 规则9——减少DNS查找
使用keep-Alive和较少的域名减少DNS查询。
作者建议：组件放在至少两个，不超过四个的主机名下，可以在减少DNS查询和允许高度并行下载之间做出很好的权衡。
10. 规则10——精简javascript
精简javascript代码，压缩脚本去除空白和注释等等。
11. 规则11——避免重定向
缺少结尾的斜线（/）是一种最浪费资源的重定向。
寻找其他方式代替重定向（取决于不同的服务器，会有不同的方式，需要自行查找）。
直接链接同样可以避免重定向。
12. 规则12——移除重复脚本
确保脚本只被包含一次。
13. 规则13——配置ETag
`响应——Last-Modified：Wed, 22 Feb 2019 04:12;12 GMT，ETag：1034f-jfd-121f`
`请求——If-Modified：Wed, 22 Feb 2019 04:12;12 GMT，If-None-Match：1034f-jfd-121f`
`响应——304 not Modified`
***问题***：如果是服务器集群，有可能每次访问的服务器都不同，使得下载次数增加，降低效率。
或者如果使用了代理，那么代理处的ETag和用户的ETag可能会有所不同，也会增加请求次数。
如果同时有If-None-Match和If-Modified，http1.1规定两个条件都必须符合才会返回304（霸道且安全）
***配置Etag***：ETag的生成组件可以自定义，比如使用文件大小和时间戳或者只使用时间戳（如果严格制定ETag，比如较大文件的内容作为组件，验证ETag将花费较长时间且成功率较低）如果不能够自定义，直接移除ETag会更好。
14. 规则14——使Ajax可缓存
Ajax在UI和web服务器之间插入了一层，位于客户端的Ajax，与web服务器交互以获取请求的信息，并与表现层交互，仅更新必要的组件。
***适用于AJAX的规则***：
    - 规则3——Expires（尽量长久）
    - 规则4——压缩组件
    - 规则9——减少DNS查询
    - 规则10——精简js
    - 规则11——避免重定向
    - 规则13——ETag——用还是不用
***隐私数据缓存***：使用SSL，SSL缓存是可缓存的，有效期是当前浏览器会话。
