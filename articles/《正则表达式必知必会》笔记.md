《正则表达式必知必会-修订版》读书笔记，这是一本非常好的正则表达式入门书籍。

## 在线工具
因为windows系统和Unix/Linux以及Mac OSX系统的文本结束标记是不同的，三个分别是\r\n，\n和\r。用了好几个在线测试的工具发现多数只识别\n，一个可以识别三种的网站--<http://www.regexp.cn/regex>。</br>
正则表达式虽然有一个标准，但是在不同的平台不同的语言中的实现时有细微的差别的，所以多多测试吧。
## 入门
正则表达式——文本搜索或者替换</br>
正则表达式的写法不止一种
## 匹配单个字符
**普通文本**  
普通文本将匹配文本本身——My将匹配My name is Nicholas中的My。</br>
正则表达式引擎一般只返回第一个匹配结果，如果需要所有结果，使用g标志。</br>
正则表达式时区分大小写的，可以使用i标识忽略大小写</br>
**匹配任意字符**   
.(英文句号)可以匹配任意单个字符</br>
特殊——.(英文句号)不能匹配换行符</br>
**匹配特殊字符**   
.(英文句号)在正则表达式中匹配任意单个字符。如果要匹配.(英文句号)本身，必须进行转义。\.(反斜线+英文句号)将匹配.(英文句号本身)。</br>
\\将匹配\ &nbsp。
## 匹配一组字符
**多个字符中的某一个**  
[abc]将匹配a或b或c三个中的某一个。</br>
**字符集合区间**   
集合|含义
---|---
[0-9]|[0123456789]
[A-Z]|[ABCDEFGHIJKLMNOPQRSTUVWXYZ]
[a-z]|[abcdefghijklmnopqrstuvwxyz]
[A-Za-z0-9]|
**排除**  
排除字符集合中的那些字符，[^0-9]表示非数字字符。
## 使用元字符
**转义**  
正则表达式中需要转义的字符:'$', '(', ')', '*', '+', '.', '[', ']', '?', '\', '^', '{', '}', '|'。</br>
**空白字符**  
常用的空白字符\r(回车符),\n(换行符),\t(制表符，Tab键)。</br>
系统| 文本行结束符
-------|----
windows | \r\n
Max OS | \r
Linux/Unix  |\n
```
文本
111
222

333

正则表达式\r\n\r\n

结果
111
222
\r\n\r\n(这里匹配到两个连续的行尾标记)
333
```
**特定的字符类型**
元字符|说明
-----|---
\d|任何一个数字（等价于[0-9]）
\D|任何一个非数字(等价于[^0-9])
\w|任何一个字母数字字符（大小写均可）或下划线(等价于[A-Za-z0-9_])
\W|任何一个非字母数字字符（大小写均包含）或下划线(等价于[^A-Za-z0-9_])
\s|任何一个空白字符(等价于[\f\n\r\t\v])
\s|任何一个非空白字符(等价于[^\f\n\r\t\v])
\x0A|十六进制(ASCII字符10，等价于\n)
\011|八进制(ASCII字符9，等价于\t)
## 重复匹配
**有多少个匹配**</br>
字符 | 说明
-|-
+|匹配一个或者多个字符(至少一个)
a+匹配一个或者连续多个a</br>
[0-9]+匹配一个或者连续多个数字</br>
[\w.]+匹配数字字母、下划线和.(英文句号)的一次或者多次出现</br>
[\w.]和[\w\.]是等价的，一般情况下在[]中不需要对元字符进行转义</br>
字符 | 说明
-|-
*|匹配零次或者多次
*可以理解为“使其可选”，可以匹配也可以不匹配</br>
字符 | 说明
-|-
?|匹配零个或者一个(最多一次)
https?://可以匹配http://或者https://。(//并不需要进行转义)</br>
**匹配的重复次数**</br>
标记|说明
--|--
{n}|重复n次</br>
{m,n}|重复最少m次，最多n次</br>
{m,}|重复至少m次</br>
{0,1}等价于？。</br>
{1，}等价于+。</br>
**防止过度匹配**</br>
量词?、*、+都是贪婪型的，匹配行为都是多多益善而不是适可而止。</br>
贪婪型量词|懒惰型量词
-|-
*|*？
+|+？
{n,}|{n,}?
## 位置匹配
**单词边界**</br>
\b用来匹配单词的开头或者结尾。</br>
\b匹配的是字符之间的一个位置：一边是单词(能够被\w匹配的字母数字字符和下划线)，另一边是其他内容(能够被\W匹配的字符)。
```
\bcat\b匹配单词cat。
\bcat匹配cat开头的单词。
```
\B-\B可以匹配到color - coded中的连字符。因为空格和-都不属于\w。</br>
**字符串边界**</br>
^代表字符串开头，$代表字符串结尾。</br>
m在JavaScript中是多行标识。
## 使用子表达式
**子表达式进行分组**</br>
使用()包含表达式，将括号中的内容看作一个整体。</br>
```
(19|20)匹配19或者20
```
**子表达式可以嵌套**</br>
嵌套表达式从内到外进行，而不是从头到尾。
## 反向引用
反向应用允许正则表达式模式引用之前匹配的结果,**只能引用括号里的子表达式**。</br>
\1匹配模式中所使用的第一个子表达式。\2匹配第二个子表达式。</br>
很多实现中，\0表示整个正则表达式。</br>
Javascript中使用$1代替\1。</br>
**替换操作**</br>
字符串的替换，一般情况下使用字符串处理功能函数更好，速度也更快。当使用反向引用进行替换时，真的非常方便。
```
原始文本
111-222-3331
222-333-4442
444-555-3333

正则：(\d{3})(-)(\d{3})(-)(\d{4})

替换：($1)  $3-$5

结果文本
(111)  222-3331
(222)  333-4442
(444)  555-3333
```
**大小写替换**</br>
 元字符 | 说明
 --|--
 \E|结束\L或\U
 \l|把下一个字符转换为小写
 \L|把\L到\E之间的字符全部转换为小写
 \u|把下一个字符转换为大写
 \U|把\U到\E之间的字符全部转换为大写
## 环视
环视操作允许利用子表达式来指定文本匹配操作的发生位置，但同时又不会消耗匹配到的文本(不出现在最终的匹配结果中)</br>
>比如你想找出<title>和</title>之间的文本，但是不需要这两个标签

**向前查看**</br>
javascript
```
文本
http://www.forta.com
https://mail.forta.com
http://gtp.forta.com

正则:.+(:)

结果
http:
https:
http:

正则：.+(?=:)

结果(返回结果没有引号:)
http
https
http
```
任何子表达式都可以转换为向前查看表达式，只要在其之前加上一个?=。同一个搜索模式里可以使用多个向前查看表达式，出现的位置没有限制。</br>
**向后查看**</br>
?<=同?=一样，必须出现在一个子表达式中，后面跟随要匹配的文本。
```
文本
$23.45
$5.31
$899.00
$69.96

正则：\$[0-9.]+

结果0：$23.45
结果1：$5.31
结果2：$899.00
结果3：$69.96

正则：(?<=\$)[0-9.]+

结果0：23.45
结果1：5.31
结果2：899.00
结果3：69.96
```
注意：向前查看模式的长度是可变的，其中可以包含.和+等量词，比较灵活。向后查看模式只能是固定长度。(几乎所有正则表达式实现都有此限制)</br>
**结合向前查看和向后查看**</br>
前面提到的想要匹配<title>和</title>之间的文本，结合向前查看和向后查看可以实现这个模式。</br>
```
文本
<title>welcome page</title>

正则：(?<=<[tT][iI][tT][lL][eE]>).*(?=</[tT][iI][tT][lL][eE]>)

结果：结果0：welcome page
```
**否定式环视**</br>
否定式向前查看会向前查看不匹配指定模式的文本。</br>
否定式向后查看则向后查看不匹配指定模式的文本。</br>
种类|说明
--|--
(?=) |肯定式向前查看
(?!) |否定式向前查看
(?<=)|肯定式向后查看
(?<!)|否定式向后查看
```
文本
I paid $30 for 100 apples,
50 oranges, and 60 pears.
I saved $5 on this order.

正则：(?<=\$)\d+
结果0：30
结果1：5

正则：\b(?<!\$)\d+\b
注释:(?<!\$>)仅当数字前面不是$时才匹配
结果0：100
结果1：50
结果2：60

正则：(?<!\$)\d+
结果0：0——($30里的0)
结果1：100
结果2：50
结果3：60
注释:因为$30中0的前面是3，所以也被匹配进来，如果不希望匹配进来，向前面那样加上单词边界。
```
## 嵌入式条件
这个功能并不经常使用，经过测试好多在线正则网站都没有实现。JavaScript也没有这个实现。</br>
正则表达式中可以添加条件
- 根据反向引用进行条件处理
- 根据环视来进行条件处理
**反向引用条件**</br>
(?(backreference)true)中的?表明这是一个条件，backreference是一个反向引用，仅当反向引用立即出现时，才对表达式求值。</br>
```
文本
123-456-7890
(123)456-7891
(123)-456-7892
(123-456-7893
1234567894

正则：(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}

结果:
结果0：123-456-7890
结果1：(123)456-7891
结果2：123-456-7893(这行结果在书中结果没有出现，但是在前面推荐的网站出现这样的结果，书中的说法没能说服我，等待发落)
```
**环视条件**</br>
```
文本
11111
22222
33333-
44444-4444

正则:\d{5}(-\d{4})?
结果0：11111
结果1：22222
结果2：33333
结果3：44444-4444

正则:\d{5}(?(?=-)-\d{4})
注释：向前查看如果-(连字符)存在，则添加-\d{4}
结果0：11111
结果1：22222
结果2：44444-4444
```

## javascript中的正则表达式
JavaScript通过String和RegExp对象的下列方法实现正则表达式处理。
- exec：用来搜索一个匹配的RegExp对象方法
- match：用来匹配一个字符串的String方法
- repalce：用来执行替换操作的String方法
- search：用来测试给定字符串是否存在匹配的String对象方法
- split：用来把一个字符串拆分为多个子串的String对象方法
- test：用来测试给定字符串里是否存在匹配的RegExp对象方法

### JavaScript注意事项
- g表示全局搜索，i表示不区分大小写，合并为gi。
- 多行字符串m,单行字符串s,忽略正则表达式模式中的空白字符x。
- 反向引用中，$`(反引号)将返回所匹配字符串之前的所有内容，$'(单引号)将返回所匹配字符串之后的所有内容，$+将返回最后一个匹配的子表达式，$&将返回所匹配到的所有内容。
- JavaScript不支持POXIS字符类。
- JavaScript不支持\A和\Z。
## 常见问题