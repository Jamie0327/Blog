
# 开班导言
## 程序员的四层境界
学会不如会学，会学不如会用，会用不如被用。
- 学会-知其所然-掌握具体编程知识
- 会学-知所以然-快速而深刻地理解技术并举一反三的程序员
- 会用-人为我用-能够将所学运用到实际编程设计之中的高级程序员
- 被用-我为人用-能够设计出广为人用的application，library，toolkit，framework等系统分析师和架构师

更高层次，发明主流设计模式，算法，语言，乃至理论等等的计算机专家。

学习编程没有速成大法，没有必杀之技，没有锦囊密集，没有终南捷径，只有思考、实践、再思考、再实践。

## 什么语言好
开放言论才能解放思想，思想解放了才能产生灵感和激情。缺乏灵感和激情的程序员，学习起来吃力，工作起来辛苦，最后就会感慨这是吃青春饭的职业。

没有激情作氧气，灵感的火花注定转瞬即逝。

真正的老师是自己。
## 语言选择
好的语言就是适合编程者和解决对象的语言。

### 语言历史
- 第一代：机器语言
- 第二代：汇编语言-Assembly
    - 汇编器将其转化为机器语言
    - 按照计算机工作的过程一步步编程，控制所有细节。包含操作寄存器，选择操作指令，保存操作结果到寄存器
    - 代码不能在跨平台
- 第三代：高级语言-C,Java,VB等
    - 编译器：将一种语言编译成另一种语言，可执行语言
    - 解释器：执行代码，输出结果
- 第四代：面向问题预压-SQL,SAS,SPSS等
    - 领域特定语言
    - 数据库操作SQL
    - 统计分析的SAS,SPSS
    - 用于科学计算的Mathematica
- 第五代：人工智能语言-prolog,Mercury,OPSS等
    - 重在目标而非过程，重在描述而非实现。只需要给智能车输入目的地，它会自己选择最佳路径，一直到终点
### 低级，中级，高级语言
低级语言：汇编语言对于了解计算机内部运行机制，调试软件和改进程序中某些关键代码的算法有帮助；

中级语言：C语言，兼具高级语言和低级语言的特征。高层抽象和可移植性，让程序员更关注问题逻辑而非机器逻辑；有指针，位字段等工具可以进行底层操作，还可以内嵌汇编语言。几乎所有操作系统和大多数高级语言都是用C实现的。

语言从低级到高级，渐渐原理机器，靠近人类，牺牲部分性能和效率，换取更高的开发效率和可维护性。中低语言更适合中小型和底层应用。高级语言：更适合大型应用。
## 编程范式
programming paradigm：计算机编程的思维方式。编程者创造虚拟世界，范式是他们采用的世界观和方法论。

> 一些范例关注代码运行的方式，例如允许副作用，或者必须按照一定的顺序来做事情。其他范例关注代码分组的方式，例如将代码放入一个或两个片段(或者许多小片段)中。其他一些范例关注的是程序的顺序和组成部分。——wikipedia

范式引导人们带有特有的倾向和思路去分析和解决问题。函数式编程范式，希望人们可以使用函数解决问题，没有副作用。面向过程，需要人们按照步骤解决问题。

## 开发技术
**框架与库和工具包**，都是一些代码的集合，提供一些API。他们的不同之处：“库和工具包是为程序员带来自由的，框架是为程序员带来约束的”。

**库和工具包**为程序员提供武器装备。<br>
**框架**利用控制反转实现对模块的统一调度，从而剥夺程序员对全局的掌控权，使他们称为手执编程武器，随时听候差遣的士兵。

**设计模式是软件的战术思想，架构是软件的战略决策。**

**设计思想**是针对某些经常出现的问题而提出的行之有效的设计解决方案，侧重思想重用。

**架构**，软件系统的最高层次的整体结构和规划，一个架构可能包含多个框架，一个框架可能包含多个设计模式。

>架构需要打好基础。<br>
框架关键是领会思想，多学习多实践。<br>
设计模式，23个模式，四人帮的GOF足矣。<br>

编程范式体现了编程的思维方式，学习编程范式能增强编程语言的语感。(学习外语最重要的是语感)

# 重要范式
## 命令范式-一切听从指挥
**命令式编程**(imperative programming)
- **冯诺依曼机运行机制的抽象**。依序从内存中获取指令和数据，然后去执行<br>
- **程序是由若干行动指令组成的有序列表,用变量存储数据，用语句执行指令**

### **过程式编程**(procedural programming)
引入了过程(procedure),函数(function)或(subroutine/subprogram)的命令式编程

### 结构化编程(structed programming)
过程式编程的基础上发展的。<br>

本质上式一种编程原则。宏观上采用“自顶向下”的设计，通过模块化将一个复杂系统分解为若干相对简单的子系统，子系统可以进一步独立解分，直到容易编码实现为止。
微观上主张采用顺序、选择和循环的逻辑结构,摒弃或限制goto语句，避免杂乱无章的代码。<br>

代表语言：Pascal语言。

## 声明范式-目标决定行动
声明式编程是**人脑思维方式的抽象**，利用数理逻辑或既定规范对已知条件进行推理或运算。"已知这，求解那"强调“做什么”而非“怎么做”。<br>

声明式编程需要数学思维
- 函数式编程类似代数中的表达式变换和计算
- 逻辑式编程类似书里逻辑推理

声明式不局限于函数式和逻辑式，SQL、XML、HTML、SVG，CSS也是声明式。
### 命令式和声明式
事实上，非命令范式的编程都可以归为声明式编程。
![](/images/编程范式.png)
其中命令式，函数式和逻辑式
![](/images/paradigm.png)

### 函数式编程
变量是抽象符号而非抽象化的内存地址。没有赋值运算（纯粹声明式），不会产生变量被改写的副作用(side effect),也不存在内存分配和释放问题。

### 递归与迭代
命令式鼓励迭代而不提倡递归。<br>
声明式提倡递归而不支持迭代。
### 总结
- 命令式编程通过一系列改变程序状态的指令来完成计算，声明式编程只描述程序应该完成的任务。
- 命令式编程模拟电脑运算，属于行动导向，关键在于定义解法，即“怎么做”，因而算法是显性的而目标是隐性的；声明式编程模拟人脑思维，是目标驱动的，关键在于描述问题，即“做什么，因而目标是显性的算法是隐形的。
- 函数式编程通过数学函数的表达式变换和计算来求值
- 逻辑式编程通过一系列事实和规则，利用数理逻辑来推导或论证结论
- 命令式编程中的变量代表抽象化的内存，所存内容可能改变。声明式编程中的变量代表抽象化的符号，所指对象一般不会改变
- 声明式编程专注问题的分析和表达而不是算法实现，不指明执行顺粗，一般没有或者极少有副作用，也不存在内存管理问题。这些都大大降低了编程的复杂度，同时也非常适合于并发式计算
- 编程语言的流行程度与其擅长的领域密切相关。函数式语言和逻辑式语言擅长数理逻辑的应用，如人工智能、符号处理、数据库、编译器等。命令式语言擅长基于业务逻辑的、尤其是交互式或事件驱动型的应用，大多数软件都是面向用户的，交互性强，多为事件驱动，业务逻辑千差万别，所以命令式更有用户之地
- 声明式语言与命令式语言之间并无绝对的界限，它们均建立于低级语言之上，互相渗透融合
- 在命令式语言中引入函数或过程，是一种向声明式风格的趋近
- 编程寻求一种机制，将指定的输入转化为指定的输出
- 三种核心编程范式的不同机制
    - 命令式：自动机机制，设计指令从初始状态到最终状态的转变
    - 函数式：数学变换机制，设计函数完成从自变量到因变量的计算
    - 逻辑式：逻辑证明机制，通过逻辑推理完成从题设到结论的证明

## 对象范式-民主制社会的编程法则
对象：实际问题中实体的抽象，具有一定的属性和功能。OOP三个基本特征：封装、继承和多态。

OOP的核心思想：以数据为中心组织逻辑，将系统视为相互作用的对象集合，并利用继承和多态来增强可维护性，可扩展性和可重用性。

封装使得对象拥有个体身份，继承使得对象拥有家庭身份，多态使得对象拥有社会身份。

> javascript不是严格的面向对象的，只是基于对象的(Object Based)
### OOP与其他范式的关系
纯粹的OOP是不存在的，必须结合其他范式。OOP适用于大型复杂的应用，交互式的，尤其于现实世界密切相关的。不适用于小型应用，数学计算，符号处理。

- OOP大多是命令式的，也有函数式和逻辑式的
- OOP不能脱离其他范式，也绝非适用于一切应用
- 可维护性，可扩展性和可重用性式所有范式和语言的共同目标，而不是OOP所独有的

软件设计最重要的不是编程语言，不是编程范式，而是抽象思想。

### OOP的优点
- 更接近人类认知，例如牛.吃(草)，而不是吃(牛，草)
- 接口简洁易记（java的接口比Unix系统API更简洁，参数少很多，将接口粗粒度化了）

所以**与其说OOP更具重用法，不如说更具以用性**。
> 过程式的函数就好比电器元件，对象就像电器产品，电器元件比电器产品更具可重用性。
### 过程式和对象式
过程式义过程为中心，自定向下，逐步求精<br>
对象式以数据为中心，自底向上，逐步合并<br>
- 过程式的模块以函数为单位，OOP的模块以对象为单位。<br>
- 过程式程序的世界式君主制的，主函数是国王，其他函数是臣民，等级分明，所有臣民听命于上级的同时也对下级发号施令，最终为国王服务；
- OO程序的世界是民主制的，所有对象都是独立而平等的公民，有权利保护自己的财产和隐私并向他人寻求服务，同时有义务为他人提供承诺的服务，公民之间通过信息交流来写作完成各种任务

## 并发范式-合作与竞争
**并发式编程以进程为导向，以任务为中心，以资源共享与竞争为主线**。以进程为单位将系统模块化，更加真实的模拟现实世界。
 
<p style="font-size:14px">举例：当一个线程因为某种资源被堵塞时，切换到其他线程而不让CPU闲置。浏览器加载文字和加载图像是在不同的线程。媒体播放器的暂停、快进、倒退、快放、慢放等等功能的实现，需要多线程处理</p>

### 并发范式特征
- 公平有效地利用资源，优化程序性能如增大吞吐量，减少响应时间，提高效率等
- 保障进程安全，防止竟态条件(Race Consitaion)
- 保持进程活性，避免死锁，饥饿，活锁，资源枯竭等
- 减少锁开销，上下文切换等性能损失
- 妥善处理多线程在算法、调试等方面地复杂性
### 五个范式的对比
![](/images/五个范式.png)

# 常用范式
## 泛型编程-抽象你的算法
泛型编程能打破静态类型语言的数据类型之间的壁垒，在牺牲效率并确保类型安全的情况下，最大限度地提高算法地普适性。

STL(standard Template Library)有3要素：算法、容器和迭代器。算法是一系列可行地步骤；容器是数据的集合，是抽象化的数组；迭代器是算法与容器之间的接口，是抽象化的指针。算法串联数据，数据实化算法。

泛型编程不仅能泛化算法中涉及的数据类型，还能泛化行为（函数，方法，运算）。

泛型编程是算法导向的，以算法为中心，逐渐将其所涉及的概念内涵模糊化、外延扩大化，并将其所涉及的运算抽象化、一般化，从而提高算法的可重用性。

## 超级范式-提升语言的级别
- 元编程是编写、操纵程序的程序。在传统的编程中，运算时动态的，但是程序本身是静态的；在元编程中，两者都是动态的。
- 元编程能减少手工编程，突破原语言的语法限制，提升语言的抽象机制与灵活性，从而提高程序员的生产效率
- 元编程有诸多应用：许多开发工具、框架引擎之类的急促软件都有自动生成源代码的功能；创造DSL以便更高效的处理专门领域的业务；自动生成重复代码；动态改变程序的语句、函数、类等等
- IDE自动生成代码通常局限性较大，小操作可能造成代码上的大差异，削弱了版本控制的意义。用自编的无需人机交互的元程序来生成代码，只须将元程序的数据来源版本化，简明而直观。同时由于元程序可以随时修改，因此局限性小，更加灵活。
- 语法导向式编程(LOP)通过创建一套专用语言DSL来编写程序。相比通用语言，DSL更简单、更抽象、更专业、更接近自然语言和声明式语言、开发效率更高，同时有助于专业程序员与业务分析员之间的合作。
- LOP一般通过元编程将专用语言转化为通用语言。
- 产生式编程与静态元编程都能自动生成源代码。产生式编程强调代码的生成，元编程强调生成代码的可执行性。此外，动态元编程并不产生源代码，但能在运行期间修改程序。(Python、Javascript、Ruby等等都具有动态元编程的功能)。静态元编程在编译期间生成代码。
- 元编程将程序作为数据来对待，有着其他程序所不具备的自觉性、自适应性和智能性，可以说是一种最高级的程序。
## 切面范式
### AOP的产生
如日志输出，代码跟踪，性能监控，异常处理，安全检查，事务管理等代码，横跨多个模块，无法用传统的方式提炼成模块，难以实现SoC和DRY。于是产生了**AOP**。

AOP是SoC原理和DRY原则的一种应用。如果一个程序是一个管道系统，AOP就是在管道上钻一些孔，在每个孔注入新的代码流。
- **SOC**是Separation of concerns的缩写，指应将关注点分离
- **DRY**是Don't repeat Yourself的缩写，指应减少重复代码。


### 相关概念
**横切关注点**指与程序的纵向主流执行方向横向正交的关注交点

**接入点(join point)**：单个的执行点称为接入点，例如，调用某个对象的方法前后。

**切入点(pointcut)**：符合预先指定条件的接入点的集合称为切入点.例如，所有以set为命名开头的方法。

**建议(advice)**：每段绑定的代码称为一个建议。

切入点与建议组成切面(aspect)，是模块化的横切关注点

**编织(weaving)**:AOP实现的关键是将advice的代码嵌入到主体程序之中，称为编织。
- **静态编织**在编译期、后编译期或加载期嵌入代码,涉及元编程和产生式编程
- **动态编织**使用代理(proxy)在运行期嵌入。
### AOP的实现
AOP的实施分为3步:切面分解、切面实现和切面合成。

**抽象和分离**是治愈代码紊乱、松散、重复的良方。抽象是前提，分解是方式，模块化是结果。抽象和分解的原则是单一化和正交化。每个模块职责明确专一，模块之间相互独立，即高内聚低耦合。
![](/images/切面.png)<br>
第三步通过AOP的工具实现，第二步是需要程序员编码的地方，并指明advice的切入点。

### OOP和AOP
OOP只能沿袭继承树的纵向方向重用，AOP可以沿横向方向重用。

AOP不是OOP的分支，也不能说超越OOP，而是OOP的补充——并不局限于OOP语言

### 建议
语言之间的天然差别、译者的专业水准、语言功底和严谨程度及时间上的滞后决定了阅读原文书籍和资料的必要性

## 事件驱动
### 事件
计算机事件通常由系统、用户或其他方式生成或触发。<br>
- 系统事件，例如计时器
- 常见的用户产生的事件：鼠标事件、键盘事件、操纵杆事件、触屏事件或设备事件(抖动、移动、倾斜、旋转等等)
- 事件循环过程中可以产生新的事件等
### 驱动编程
**流程驱动式编程**(flow-drived programming)：主动轮询(polling)，行为取决于自身的观察判断(上课打瞌睡，对周围保持警戒，一有异动立刻挺直身板)。<br>
**事件驱动式编程**(event-drived programming)：托付给别人，等待通知(notification)，行为取决于外来的突发事件(打瞌睡，让同桌在有异动时提醒自己)。<br>
> 主动打电话推销是流程驱动的；接线员等电话是事件驱动的<br>公共汽车时流程驱动，出租车是事件驱动的<br>主动检查所关心的内容是否更新是流程驱动，用订阅的方式是事件驱动<br>
### 事件驱动编程
**观察者模式又名发布/订阅模式，即是事件驱动式的简化，也是事件驱动式的核心思想**。MVC架构是观察者模式在架构设计上的一个应用。

事件驱动式编程的三个步骤：实现事件处理器；注册事件处理器；实现事件循环。
- 事件处理器负责处理事件，经注册方能在事发时收到通知
- 事件循环负责侦查事件、预处理事件、管理事件队列和分派实践等，无事时默默等待，有事立即响应。
![](/images/事件驱动.png)
> 在事件驱动的应用程序中，通常有一个主循环，它侦听事件，然后在检测到其中一个事件时触发一个回调函数。在嵌入式系统中，可以使用硬件中断而不是持续运行的主循环来实现相同的目的。事件驱动的程序可以用任何编程语言编写，但是使用提供高级抽象的语言(如await和closures)更容易完成此任务。

事件驱动式最重要的两个特征：被动性和异步性。被动性来自控制反转，异步性来自会话切换。
- 控制反转导致了事件驱动编程的被动性
- 异步性，是由于事件的不可预测性和随机性决定

### 控制反转
一般都是高层代码调用底层代码，callback反其道而行之，称为**控制反转**。控制反转可以降低模块之间的依赖性，从而降低模块的耦合度和复杂度。
![](/images/回调函数.png)
控制反转一般通过callback来实现。<br>
callback指能作为参数传递的函数或代码，它允许底层模块调用高层模块，使调用者与被调用者从代码上解耦。异步callback在传入后并不立即被调用，使调用者与被调者从时间上解耦。

**控制反转、依赖反转原则和依赖注射**是近义词，主题是控制和依赖，目的是解耦，方法是反转，实现这一切的关键是抽象接口(包括函数指针、抽象类、接口、C++中的泛型函子和C#中的委托)。

**为什么说抽象接口而不是回调函数？**<br>
回调函数较为古老，多出现于过程式编程。抽象接口更现代、更OO的说法。回调，强调的是行为——低层反调高层。抽象强调实现方式——接口具有抽象性，底层才能在调用它时无需顾及高层的具体细节，从而实现控制反转。
- [wikipedia-IoC](https://en.wikipedia.org/wiki/Inversion_of_control)
### 异步
异步过程在主程序中以非堵塞的机制运行，即主程序不必等待该过程的返回就能继续下一步。异步机制能减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。 

独立是异步的前提，耗时是异步的理由。

# 重温范式
## 函数范式
> 单靠记忆只能触及知识之表，单靠练习只能深入知识之里，唯有培养方能渗透知识之根。

> 在学习时不妨略过一些细节和难点，先概览全貌以获取感性认识，然后在逐步积累中升华为理性认知。

**每种范式代表着一套独特而有效地解决问题地思想和方法**
> 软件范式除了编程范式，还有架构范式，数据库范式等。Object-oriented可以应用于编程、架构和数据库，分别为OOP，OOA，OODB。

> 编程语言地语法、语义都是从编程范式的树根衍生而出的枝叶。每种范式擅长处理的问题领域不尽相同。

过程式和函数式的区别，相当于机器思维和数学思维的区别。
### 函数式的特征
- 函数是头等公民，属于高阶函数
- 无副作用或尽量减少副作用
    - 无副作用，指函数在被调用前后保持程序的状态不变。不改变非局部变量的值，不改变传入的参数，也没有IO操作
    - 函数式并非不改变内存，而是改变的是栈内存罢了(有待商榷，现代计算机有固定大小的数据类型存放在栈中)
    - 如果涉及流程控制、顺序操作、状态维护、I/O运算等，没有副作用是很不方便的，于是函数式提供了**monad**
- 提倡使用递归实现迭代操作。递归需要维护栈，并且随着递归深度加深消耗空间变大，如果能够转换为尾递归，可以优化消耗空间
- 惰性求值，指在计算表达式时如何处理函数参数
    ```c
    print length([2+1, 3*2, 1/0, 5-4])
    // 在严格模式下，执行失败，因为第三项0作为除数
    // 如果是惰性求值，返回4
    ```
#### 无副作用的优点
- 函数易于重构、调试和单元测试。
- 代码有效性与函数顺序无关，方便**并发**处理和优化处理。
- 还可以利用**惰性求值**(避免不必要的等待和计算)
- **引用透明**，表达式随时可以用它的值来替换。

## 逻辑范式
算法=逻辑+控制。<br>
逻辑式编程将算法中的控制部分大都移交给编程语言，编程人员主要关注算法的核心逻辑。

逻辑式编程不仅适用于人工智能方面的学术研究，同样广泛适用于各种涉及知识管理、决策分析等方面的应用领域。

逻辑式与过程式和函数式的一个不同之处是，它没有明显的输入、输出之分。

## 范式汇总
设计模式重在设计，对语言和工具的要求不高，而编程范式须要建立一套抽象机制和方法体系，离不开语言或工具的支持。

编程范式的核心价值在于，突破原有编程方式的某些限制，带来新思维和新方法，进一步解放程序员的劳动力。

#### 编程范式:命令式/过程式(imperatice/Procedural)
代表语言|Fortran/Pascal/C
---|---
核心概念|命令/过程
运行机制|命令执行
关键突破|突破单一主程序和非结构化程序的限制
实现原理|引入逻辑控制和子程序
主要目的|模拟机器思维，实现自顶向下的模块设计
常见应用|交互式、事件驱动型系统、数值计算等

#### 编程范式:函数式/应用式(Functional/Application)
代表语言|Scheme/Haskell
---|---
核心概念|函数
运行机制|表达式计算
关键突破|突破机器思维的限制
实现原理|引入高阶函数、将函数作为数据处理
主要目的|模拟数学思维，简化代码，减少副作用
常见应用|微积分计算、数学逻辑、博弈等

#### 编程范式:逻辑式(Logic)
代表语言|Prolog/Mercury
---|---
核心概念|断言(predicate)
运行机制|逻辑推理
关键突破|突破逻辑与控制粘合的限制
实现原理|利用推理引擎在已知的事实和规则的基础上进行逻辑推断
主要目的|专注逻辑分析，减少控制代码
常见应用|机器证明、专家系统、自然语言处理、语义网(semantic web)、决策分析、业务规则管理等

#### 编程范式:对象式(Object-Oriented)
代表语言|Smalltalk/Java
---|---
核心概念|对象(Object)
运行机制|对象间信息交换
关键突破|突破数据与代码分离的限制
实现原理|引入封装、继承和多态机制
主要目的|迎合人类认知模式、提高软件的易用性和重用性
常见应用|大型复杂交互式系统等

#### 编程范式:并发式/并行式(Concurrent/Parallel)
代表语言|Erlang/Oz
---|---
核心概念|进程/线程(Process/Thread)
运行机制|进程/线程间通信与同步
关键突破|突破串行的限制
实现原理|引入并行的线程模块及模块间的通信与同步机制
主要目的|充分利用资源、提高运行效率、提高软件的响应能力
常见应用|图形用户界面、IO处理，多任务系统如操作系统、网络服务器等，实时系统，嵌入式系统，计算密集型系统如科学计算、人工智能等

#### 编程范式:泛型式
代表语言|Ada/Eiffel/C++
---|---
核心概念|算法
运行机制|算法实例化(多发生于编译期)
关键突破|突破静态类型语言的限制
实现原理|利用模板推迟类型推定
主要目的|提高算法的普适性
常见应用|普适性算法如排序、搜索等，集合类容器等

#### 编程范式:元编程(Metaprogramming)
代表语言|Lisp/Ruby/Javascript
---|---
核心概念|元程序
运行机制|动态生成代码或者自动修改执行指令
关键突破|突破语言的常规语法限制
实现原理|利用代码生成或语言内建的反射(reflection)、动态等机制，将程序语言作为数据来处理
主要目的|减少手工编码，提升语言级别
常见应用|自动代码生成，定义机构化配置文件、IDE、编译器、解释器、人工智能、模型驱动架构(MDA)、领域特定语言(DSL)等

#### 编程范式:切面式(Aspect-Oriented)
代表语言|AspectJ/AspectC++
---|---
核心概念|切面
运行机制|在接入点执行建议
关键突破|突破横切关注点无法模块化的限制
实现原理|通过编织将附加行为嵌入主体程序
主要目的|实现横切关注点分离
常见应用|日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理等

#### 编程范式:事件驱动(Event-Driven)
代表语言|C#/VB.NET
---|---
核心概念|事件(Event)
运行机制|监听器收到事件通知厚做出响应
关键突破|突破顺序、同步的流程限制
实现原理|引入控制反转和异步机制
主要目的|调用者与被调用者在代码和时间上双重解耦
常见应用|图形用户界面，网路应用、服务器、操作系统、IoC框架，异步输入，DOM等








