一本计算机基础知识的入门指导书

# 预备知识
> 计算机科学并非一门研究机器的学科，如同天文学并非研究望远镜一样。从本质上讲，数学和计算机科学具有统一性。———Edsger Dijkstra
## 建模
数学建模把生活、工作和社会中的实际问题转化成数学题来解决。计算机的出现以及功能主要是提高手工作业的效率，所以如果希望使用计算机解决问题，首先必须将问题抽象成可以解决的问题。</br>
使用流程图或者伪代码描述解决问题的过程。<br>
## 逻辑
命题：能够判断对错的陈述句。<br>
命题为真，称为true。命题为假，称为false。<br>

**条件运算符->**<br>
A->B表示当A=true时，B=true

**取反运算符!**<br>
!A表示对A取反。

**逆否命题**<br>
A->B等价于逆否命题!B->!A

**双条件语句（双向蕴含）**<br>
A<->B表示A当且仅当B。当A->B和B->A均为真时，A<->B为真

**逻辑与，逻辑或，逻辑异或**<br>
逻辑与——AND——全部条件为真时结果为真
逻辑或——OR——任意条件为真结果为真
逻辑异或——XOR——条件相反时结果为真

### 布尔代数
布尔代数可以用来简化逻辑表达式。

**结合律**：括号不影响运算的顺序<br>
A AND (B AND C) = (A AND B) AND C<br>
A OR (B OR C) = (A OR B) OR C

**分配律**<br>
A AND (B OR C) = (A AND B) OR (A AND C)<br>
A OR (B AND C) = (A OR B) AND (A OR C)<br>

**德摩根定律**<br>
!(A AND B) = !A OR !B<br>
!A AND !B = !(A OR B)<br>

### 真值表
使用真值表分析逻辑表达式。
A|B|A AND B|!(A AND B)|!A|B!|!A OR !B
-|-|-|-|-|-|-
true|true|true|false|false|false|false
true|false|false|true|false|true|true
false|true|false|true|true|false|true
false|false|false|true|true|true|true
比较!(A AND B) 和 !A OR !B则可以直观的观察到德摩根定律。

### 逻辑在计算中的应用
通过逻辑门电路对电流执行逻辑运算，完成逻辑表达式的计算，是计算机的基础。<br>
推荐：《穿越计算机的迷雾》中有关于计算机逻辑电路的详细解释

## 计数
计数的两个基本原则：乘积法则和求和法则。
### 乘法
如果一个事件以n种不同的方式发生，另一个事以m种方式发生，那么两个事可能以n X m不同的方式发生。
### 排列
对于n个项，存在n的阶乘(n!)种排序方法。第一项有n个选择，第二项有n-1个选择……n-1项有2个选择，第n项只有一个选择。n！=nX(n-1)X(n-2)X……X2X1

n个不同项选择m项的排列,第一项有n个选择，第二项有n-1个选择……到第m项后停止，结果为n!/(n-m)!<br>
### 具有相同项的排列
n项中有r个项相同，则结果为n!/r!.
### 组合
组合与排列的不同之处就是元素没有顺序。<br>
从n个项中选择m个项的数量，m的排列数量为m!,组合数量为1，组合的数量在排列的基础上除以m!，结果为n!/(n-m)!m!
### 求和
高斯求和：1+2+……+(n-1)+n=n(n+1)/2

## 概率

### 对结果计数
P(事件)=事件发生的次数/可能的结果数量
比如骰子，偶数的点数为3个，2、4、6,所以概率为3/6=1/2
### 独立事件
如果一个事件的结果不会对另一个事件的结果产生影响，则二者相互独立。<br>两个独立事件发生的概率是它们各自改概率的乘积。<br>
比如三张彩票，每张的中奖概率为1/2，则三张都中奖的概率为1/2*1/2*1/2=1/8。
### 互斥事件
假如两个事件不可能同时发生，则称为互斥。<br>
如果希望任一互斥事件发生，将它们各自的概率相加即可。<br>

### 对立事件
如果两个互斥事件涵盖所有可能的结果，则称两者对立。<br>

城堡有5座炮塔，每座炮塔有20%的概率在入侵者到达城堡前消灭它们。消灭入侵者的概率有多大呢？
- **不要将各个独立事件的概率相加！**
- “所有炮塔未命中”和“至少有一座炮塔命中”互为对立事件
- “所有炮塔未命中”的概率为0.8<sup>5</sup>=0.33
- 至少一座炮塔命中的概率为1-0.33=0.67
### 赌徒谬误
彩票等都是独立事件，过去的事件不会影响独立事件的结果——永远不会。
### 高级概率
二线分布
# 复杂度
## 时间复杂度
时间复杂度T(n)，表示输入规模为n时程序的运行次数。<br>

时间复杂度主要取决于增长最快的项，例如T(n)=n<sup>2</sup>+n，则T(n)约为n<sup>2</sup>。<br>

## 大O符号
 O(2<sup>n</sup>)>O(n<sup>2</sup>)>O(n log n)>O(n)>O(log n)>O(1)
## 指数
指数复杂度随着输入增长过快，计算机处理能力有限，可认为“无法运行”。

T(n!)比指数T(2<sup>n</sup>)更差。

虽然指数和阶乘复杂度用来解决NP完全问题。
## 内存
算法执行所需的空间称为空间复杂度。

# 策略
找到一种好的走法后，设法寻找更好的走法——伊曼纽尔.拉斯克
## 迭代
迭代策略利用循环中(例如for和while)来重复一个过程，直到满足某个条件。循环中的每一步称为迭代。

举例合并两个有序数组，merge操作，时间复杂度为O(n)
### 循环嵌套和幂集
给定对象S的集合，其幂集是由S的全乎子集构成的集合。

如果输入规模每增加一项导致算法的运算次数加倍，表示该算法具有指数时间复杂度O(2<sup>n</sup>)

构建幂集相当于构建真值表，每个元素要么在当前子集或者不在，可以表示为true和false。
## 递归
递归表示函数在定义中调用自身。

可以用来解决那些涉及自身定义的问题，比如斐波那契数列。

举例，判断一个单词是否是回文，首尾相同，首尾之间的子单词同样属于回文。

递归算法中，当输入缩小到无法再缩小时达到**基线条件**。
### 递归和迭代
递归和迭代比较，代码量会少一些，但是递归必须保存未完成的递归调用及其部分计算，消耗内存。并且从当前调用切换到下一个递归并返回，需要额外的CPU周期。<br>

总是可以用迭代形式重写递归算法来避免开销，迭代速度更快，但是比递归复杂且更难理解一些。
## 蛮力法
蛮力策略对问题所有可能的候选解进行检验，也叫**穷举搜索**。

举例，最佳交易日和背包问题（NP完全问题）。
## 回溯法
回溯：回滚到前一个位置，然后继续搜索。

八皇后问题。

如果解是一系列选择，且后续选择受限于已做出的选择，则回溯法是求解问题的最有效方法。
## 启发法
启发式是一种不保证得到最佳解或最优解的方法。
当蛮力法或回溯法这样的方法过慢时，改用启发式可能会有帮助。
### 贪心法
与回溯相反，贪心法尝试每一步都做出最佳选择，并且不会回退到之前的选择。

背包问题(邪恶版本)：每一步选择价值最高的物品。

旅行推销员(NP完全问题):到访最近一座未曾到访的城市。
## 分治法
将问题分解成若干相似但更小的子问题，反复进行分解操作，直至子问题变得易于求解；将各个子问题的解合并在一起，即可得到原问题的解。拿破仑统治欧洲，因为他们对敌人采取分而治之的策略。

### 分治求解排序问题
归并排序。

归并排序，把问题分解成类似二叉树，所以一共分解log<sub>2</sub>n步。每一步（就像二叉树的每一层）都需要对n个元素排序，事件复杂度为O(n)。所以时间复杂度为nlog<sub>2</sub>n。

最佳交易问题——使用分支法，可达到复杂度nlogn。


背包问题,将n件物品的解定义为n-1件物品的最大子解<br>
K(n,c)为选择n件物品获得的最大利润，w<sub>n</sub>表示第n件物品的重量，v<sub>n</sub>表示第n件物品的价值:<br>K(n,c)=max(K(n-1,c),K(n-1,c-w<sub>n</sub>)+v<sub>n</sub>)

## 动态规划
动态规划旨在找出重复的子问题，以便对每个子问题只计算一次。记忆化时动态规划中的一种常用的方法。

记忆化求解斐波那契数列。

记忆化求解背包问题。

### 自底向上求解最佳交易问题
自顶向下求解，输入不断减小，直到达到基线条件。
自底向上：首先计算基线条件，不断进行组合，直至得到通解。

自底向上求解最佳交易问题。时间复杂度O(n)。根据卖出日期求解买入日期。

## 分支界定法
当解时一系列选择时，通常采用分支界定的策略，通过快速检测并丢弃不可行的选择以节省时间。

### 上界和下界
如果背包问题中的物品可以分割，则可以给出最优解的上界。
贪心算法可以给出最优解的下界。

使用分支界定，上界和下界可以排除一些候选，缩短执行时间。
求解步骤：
1. 将问题分解为若干子问题
2. 找出每个子问题的上界和下界
3. 比较所有分支的界限
4. 对最可行的子问题重复第一步
## 总结
求解问题的过程，是从可能的解空间中寻找正确解的过程。

蛮力法最简单，逐个检验搜索空间的元素求解问题。<br>
将问题分解为更小的问题能显著提高性能。<br>
如果分解过程涉及相同子问题的处理，这种情况下，动态规划以避免重复执行相同的计算很重要。<br>
回溯法可以优化一些类型的蛮力搜索。<br>
如果可以估算问题的上界和下界，分支界定可以缩短求解时间。<br>
如果求解最优解成本过高，则可以使用启发法(贪心等)。
# 数据
## 抽象
### ADT
ADT是一个数据结构和定义在该结构上的一组操作的总称。<br>

ADT将数据在内存中存储和操作的所有细节都隐藏起来<br>
## 常见抽象
栈，队列，优先队列，列表，排序列表，映射，集合等
## 数据结构
数据结构定义了数据在计算机内存中的组织和访问方式，并提供了在数据处理模块中实现ADT的方法。
### 数组
可立即访问。空间连续，可扩展性差，添加/删除操作性能较低
### 链表
不必连续存储，可扩展性好，添加/删除性能好。随机访问耗时，需要从头开始检索。无法访问前一个元素。
### 双向链表
随机访问，必须从头检索。每个单元两个指针，代码复杂一些，且比较耗内存。
### 树
存储空间不连续。具有层次结构。一个父节点 
### 二叉查找树
高效搜索的树结构。

如果树能够完美平衡，树的最小高度为log<sub>2</sub>n.搜索的时间复杂度为O(logn).常用来实现集合与映射。

红黑树是一种自平衡树，经常用于实现映射，迅速查找任何给定的键。

AVL是另一种自平衡树。比红黑树插入和删除较慢，但是平衡性更好，检索元素比红黑树更快。频繁进行读操作时，可以使用AVL。

B树一个节点可以存储一个以上元素，可以包含两个以上的子节点，提高对大数据块的操作。常用于数据库操作。
### 二叉堆
实现优先队列时尤其有效。
频繁对集合最大(小)元素进行操作，二叉堆是一个不错的选择。
### 图
图是最灵活的数据结构，几乎可以表示所有类型的数据。

非常适合描述社交网络。
### 散列表
查找时间复杂度为O(1).

连续空间存储。

常用于实现映射和集合。能够更快的插入和删除。
# 算法
## 排序

## 
# 参考及深入推荐
## 第一章参考
- 《离散数学及其应用(第七版)》
## 第二章
- 《计算机程序设计艺术》卷1
- P vs NP and the computational Complexity Zoo
- What Is Big O?
## 第三章
- 《算法设计》
- “chooing Algorithm Design Stratery”
- 《算法概论》第六章-动态规划
## 第四章参考资料
1. [computer algorithms:Balancing a binary search tree by stoimen](https://dzone.com/articles/algorithm-week-balancing)
2. [cornell.edu——Abstract data types and Data structures](http://www.cs.cornell.edu/Info/Courses/Spring-98/CS211/lectureNotes/05-StacksAndQueues.pdf)
3. [Abastract Data Types](http://cse.iitkgp.ac.in/pds/notes/ADT.html)
4. [search tree implementation](https://runestone.academy/runestone/books/published/pythonds/Trees/SearchTreeImplementation.html)

## 第五章算法
- [算法列表-wikipedia](https://en.wikipedia.org/wiki/List_of_algorithms)
- 《算法图解》
- 《算法》
- 《算法导论》
## 第六章-数据库
- 《数据库系统概念》
- 《NoSQL精粹》
- 《分布式数据库系统原理》
## 第七章-计算机
- 《计算机组成：结构化方法》
- 《现代编译原理：c语言描述》
## 第八章-程序设计
- 《Essentials of Programming Languages》pdf
- 《代码大全》
## 
- [编程范式](https://en.wikipedia.org/wiki/Programming_paradigm)