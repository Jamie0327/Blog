如果想要轻松愉快的入门数据结构与算法，推荐《我的第一本算法书》，一本用图教大家数据结构和算法过程的书，读起来很轻松并且很直观。因为javascript与其他传统的语言不同，除了原始类型（字符串、布尔值、数字、null、undefined，再加上一个es6的Symbol），其他类型都是对象。想要高效的实现常用的数据结构，还是有必要阅读此类书籍。
为了跟上语言版本练习写代码，也推荐另一本《学习javascript数据结构与算法》（第三版），用ES6书写数据结构和算法。因为js的数组也是对象，这本书中选择了用对象代替数组实现其他栈、队列等数据结构。忘记在那本书中，在不同的浏览器中数组和对象的性能，因为浏览器底层实现的不同得到不同的结果，所以如果涉及大量数据，可以测试两种不同的实现来选择。这是stackflow上一个关于两者性能的[讨论帖子](https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript)，感兴趣的可以看看。

只记录需要特别注意的地方，结合《学习javascript数据结构与算法第三版》
### js基础
- js函数的参数都是按值传递（没有按照引用传递的参数）。
- 变量的作用域是指一个变量在程序中的哪些地方可以访问。
- 任何可以被递归定义的函数，都可以被改写为迭代式的程序。
### 数组和列表
数组可以按照以下标随机访问
- javascript的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，数字索引在内部被转换为字符串类型，因为js对象的属性必须是字符串。
- 脚本语言中，数组中的元素不必是同一种数据类型。
- 字面量创建数组比Array构造函数更高效
- js数组是对象，所以数组的长度可以任意增长
### 栈
- 利用栈将一个数字从一种数制转换成另一个数制
    - 最高位为n%b，将次位压入栈
    - 使用n/b代替n
    - 重复上面两步骤，直到n等于0，且没有余数
    - 将栈内元素弹出，直到栈为空，一次将这些元素排列，就会得到转换后数字的字符串形式
- 回文判断
   - 字符串完整入栈，依次弹出每个字母得到一个新的字符串，该字符串与原字符串顺序相反，比较两个字符，相等则是回文
- 用栈实现递归（就像函数调用栈一样，栈经常被用来实现编程语言）
- 用两个栈（操作数栈和运算符栈）实现算术运算
- 汉诺塔（栈先进后出）
### 队列
- 双端队列：（约瑟夫环问题）圆圈中第n个人淘汰，1~n-1出队后又入队，删除第n个，直到剩一人
- 回文：双端队列两端同时出队，相等则为回文
- 优先队列（虽然叫队列，本质是根据每个元素的优先级代码来决定出队顺序）
- 
### 链表
相对于数组，插入删除元素效率更高。
- 圆圈淘汰（约瑟夫环问题），用循环链表实现
### 字典
字典以键-值形式存储数据。字典的主要用途通过键取值。
ES6增加了map，可以不用自行实现。
### 散列表
使用散列函数将键映射为一个数字，数字的范围是0到散列表的长度。
- 用质数作为散列表的长度，如果键是随机的整数，可以更加均匀的分布这些键。
```
hashCode(string){
  const H = 37
  var total = 0
  for(let i=0;i<string.length;i++){
    total += H*total + string.charCodeAt(i)
  }
  total = total % 1013
  return parseInt(total)
}
```
- 碰撞处理：如果数组的大小是待存储数据个数的两倍以及两倍以上时，选择使用线性探测法
    - 开链法：在冲突的位置使用数组或者链表存储多个数据
    - 线性探测法：如果出现冲突，顺序查找一个空位置，把数据放在该空位置
### 集合
元素无序且唯一。
ES6增加了set类型。
### 二叉树
二叉搜索树（查找树），较小的值存左节点，较大的值存在右节点
- BST插入算法
    1. 设根节点为当前节点；
    2. 如果待插入节点小于当前节点，设置新的当前节点为原节点的左节点；反之，执行第四步；
    3. 如果当前节点的左节点为null，新节点插入该位置，退出循环；反之，继续执行下一次循环
    4. 设置当前节点为原节点的右节点
    5. 如果当前节点的右节点为null，将新的节点插入这个位置，退出循环；反之，继续下一次循环
- 遍历节点
    1. 中序遍历的结果：所有数据从小到大的顺序
    2. 先序遍历
    3. 后序遍历
- BST查找
    1. 最小值：BST最左的节点
    2. 最大值：BST最右节点
    3. 给定值
- BST删除节点
    1. 如果是叶子节点，只需要将父节点指向它的链接指向null
    2. 如果只包含一个子节点，原本指向它的节点指向它的子节点
    3. 如果包含两个子节点，查找右子树的最小值（左子树的最大值），用最小值更新需要删除节点的值，相当于被移除了
    4. 删除右子树的最小值
- BST的其他用途：记录一组数据集中数据出现的次数
### 图和图算法
使用邻接表表示图，邻接表由图中每个顶点的相邻顶点列表组成，可以使用数组、链表、散列表或字典来表示相邻顶点列表。
- 深度优先遍历：访问没有访问过的节点，标记为已访问，再递归访问初始顶点的邻接表中没有访问过的顶点
- 广度优先遍历（类似按层遍历树）：将顶点加入队列，访问先入队的节点，将相邻顶点加入到队列中
- 查找最短路径：使用广度优先所有对应的最短路径
### 排序和搜索算法
- 冒泡排序
- 选择排序
- 插入排序
- 希尔排序
- 归并排序
- 快速排序
- 堆排序
- 计数排序
- 桶排序
- 基数排序
- 顺序搜索
- 二分搜索（已排序的基础上）
### 动态规划
**动态规划**与分治法是不同的方法，分治法是把问题分成相互独立的子问题，然后组合它们的答案（二分搜索）。动态规划将问题分解成相互依赖的子问题。
- 背包问题
- 最长公共子序列
- 矩阵链相乘
- 硬币找零
- 图的全源最短路径
### 贪心算法
**贪心算法**遵循一种近似解决问题的能力。很多问题寻找最优解的代价太大，用局部最优解解决问题，即使不是整体最优解。
- 最少硬币找零
- 分数背包问题
### 回溯算法
回溯是一种渐进式寻找并构建问题解决方式的策略。从一个可能的工作开始试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到问题解决
- 骑士巡逻问题
- N皇后问题
- 迷宫老鼠问题
- 数独解题器